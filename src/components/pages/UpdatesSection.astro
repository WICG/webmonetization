---
import UpdatesWrapper from "./UpdatesWrapper.astro"; 
import type { Updates } from '../../types/blog'; 

interface Props extends Updates {}; 
const { updates } = Astro.props; 
---

<section class="section">
  <div class="contentWrapper">
    {updates.length > 0 && (
      <h2 class="updates-heading">Important Updates</h2>
      <UpdatesWrapper updates={updates} />  
    )}
    <div class="updates-dots" id="updates-dots">
      {updates.map( update => <span></span>)}
    </div>
  </div>
</section>

<style>
.updates-heading {
  font: var(--font-h2);
  margin-bottom: var(--spacing-lg);
}

.updates-dots {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: var(--spacing-xs);
}

.updates-dots span {
  display: inline-block;
  width: var(--spacing-sm);
  height: var(--spacing-sm); 
  border-radius: 50%;
  border: none;
  background-color: #D9D9D9;
}

.updates-dots span.active-dot {
  background: linear-gradient(to right, var(--gradient-3-start), var(--gradient-3-stop));
}

@media screen and (max-width: 1034px) {
  .updates-heading {
    font: var(--font-h4);
    text-align: center;
  }
  .updates-dots {
    margin-bottom: var(--spacing-lg);
  }
}
</style>

<script>
  const updatesContainer = document.querySelector('#updates-list');
  const prevButton = document.querySelector('#prev-button');
  const nextButton = document.querySelector('#next-button');
  const carouselDots = document.querySelectorAll('#updates-dots span');
  const carouselLinks = document.querySelectorAll('a.carousel-links');
  const numberOfUpdates = carouselDots.length;

  if (updatesContainer instanceof HTMLElement) {
    let width = updatesContainer.offsetWidth;

    window.addEventListener('resize', () => {
      width = updatesContainer.offsetWidth;
      const currentIndex = getCurrentSlideIndex();

      updatesContainer.scrollTo({
        left: currentIndex * width,
        behavior: 'auto'
      })
    });

    prevButton?.addEventListener('click', () => scrollUpdates('left'));
    nextButton?.addEventListener('click', () => scrollUpdates('right'));
    
    carouselDots[0].classList.add('active-dot');
    updateTabIndices(0); 

    function scrollUpdates(direction: 'left' | 'right') {
      const amount = direction === 'left' ? -width : width

      updatesContainer?.scrollBy({
        left: amount,
        behavior: 'smooth',
      });

      // check for scrollend support
      if ('onscrollend' in window) {
        updatesContainer?.addEventListener('scrollend', ()=> afterScroll(direction)); 
      }
      else {
        let scrollTimeout:NodeJS.Timeout; 
        updatesContainer?.addEventListener('scroll', ()=> {
          clearTimeout(scrollTimeout); 
          scrollTimeout = setTimeout(()=>afterScroll(direction), 0)
        }); 
      }
    }

    function afterScroll(direction: "left" | "right") {
      const currentIndex = getCurrentSlideIndex();
      updateUI(direction, currentIndex); 
      updateTabIndices(currentIndex); 
    }
    
    function updateTabIndices(currentIndex : number){
      carouselLinks.forEach( (link, i) => {
        if(link instanceof HTMLAnchorElement) {
          link.tabIndex = i === currentIndex ? 0 : -1;
        }
      });
      if(prevButton instanceof HTMLButtonElement && nextButton instanceof HTMLButtonElement){
        prevButton.tabIndex = currentIndex === 0 ? -1 : 0; 
        nextButton.tabIndex = currentIndex === (numberOfUpdates - 1) ? -1 : 0; 
      }
    }

    function updateUI(direction: 'left' | 'right', currentIndex : number) {
      const indexToGo =
        direction === 'left'
          ? currentIndex - 1 >= 0
            ? currentIndex
            : 0
          : currentIndex + 1 <= numberOfUpdates - 1
            ? currentIndex
            : numberOfUpdates - 1
      
      carouselDots.forEach((dot) => dot.classList.remove('active-dot'));
      carouselDots[indexToGo].classList.add('active-dot');

      prevButton?.classList.remove('inactive-arrow');
      nextButton?.classList.remove('inactive-arrow');

      if(indexToGo === 0) {
        prevButton?.classList.add('inactive-arrow');
      }

      if(indexToGo === (numberOfUpdates - 1)) {
        nextButton?.classList.add('inactive-arrow');
      }
    }

    function getCurrentSlideIndex() {
      if (!updatesContainer) return 0;

      const scrollLeft = updatesContainer.scrollLeft;
      const currentIndex = Math.round(scrollLeft / width);
      return currentIndex;
    }
  }
</script>